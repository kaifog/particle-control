<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Particles</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #050505; 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
        }
        
        /* Video hidden, used for computer vision processing */
        #input_video { 
            position: absolute; 
            top: 0; 
            left: 0; 
            opacity: 0; 
            pointer-events: none; 
            z-index: -1; 
        }
        
        /* Small preview of what the camera sees */
        #cam-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.1);
            transform: scaleX(-1); /* Mirror effect */
            z-index: 5;
            object-fit: cover;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        /* UI Overlay for controls */
        #ui-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 10;
            background: rgba(10, 10, 10, 0.6);
            padding: 12px 20px;
            border-radius: 40px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 1px;
            outline: none;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-color: rgba(255, 255, 255, 0.6);
        }

        button.active {
            background: white;
            color: black;
            border-color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffffff;
            font-size: 14px;
            background: rgba(0,0,0,0.6);
            padding: 8px 16px;
            border-radius: 20px;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .dot {
            width: 8px;
            height: 8px;
            background-color: #ff3333;
            border-radius: 50%;
            display: inline-block;
        }

        .dot.active {
            background-color: #00ff88;
            box-shadow: 0 0 8px #00ff88;
        }
        
        #instructions {
            position: absolute;
            top: 70px;
            left: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            max-width: 250px;
            pointer-events: none;
            line-height: 1.5;
        }
    </style>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="status"><span class="dot" id="status-dot"></span> <span id="status-text">Initializing AI...</span></div>
    <div id="instructions">
        üëã <b>Show Hand:</b> Attract particles<br>
        ü§è <b>Pinch:</b> Compress/Expand shape<br>
        ‚ÜîÔ∏è <b>Move Left/Right:</b> Change Color
    </div>

    <!-- Hidden video for processing -->
    <video id="input_video" autoplay playsinline></video>
    <!-- Visible mirror preview -->
    <video id="cam-preview" autoplay playsinline muted></video>

    <div id="ui-container">
        <button onclick="setShape('sphere')" class="active" id="btn-sphere">Sphere</button>
        <button onclick="setShape('heart')" id="btn-heart">Heart</button>
        <button onclick="setShape('saturn')" id="btn-saturn">Saturn</button>
        <button onclick="setShape('flower')" id="btn-flower">Flower</button>
        <button onclick="setShape('dna')" id="btn-dna">DNA</button>
        <button onclick="setShape('cube')" id="btn-cube">Cube</button>
    </div>

<script>
    /**
     * CONFIGURATION
     */
    const PARTICLE_COUNT = 20000;
    const PARTICLE_SIZE = 0.15;
    const CAMERA_Z = 35;
    
    /**
     * THREE.JS SETUP
     */
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02); // Depth cueing

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = CAMERA_Z;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
    document.body.appendChild(renderer.domElement);

    /**
     * PARTICLE SYSTEM
     */
    const geometry = new THREE.BufferGeometry();
    
    // Arrays to store data for GPU
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // Where particles want to be
    
    // Initialize random positions
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const x = (Math.random() - 0.5) * 100;
        const y = (Math.random() - 0.5) * 100;
        const z = (Math.random() - 0.5) * 100;
        
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
        
        // Initialize targets as random too initially
        targetPositions[i * 3] = x;
        targetPositions[i * 3 + 1] = y;
        targetPositions[i * 3 + 2] = z;

        // White init color
        colors[i * 3] = 1;
        colors[i * 3 + 1] = 1;
        colors[i * 3 + 2] = 1;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Create a soft glowing particle texture
    const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

    const material = new THREE.PointsMaterial({
        size: PARTICLE_SIZE,
        vertexColors: true,
        map: sprite,
        blending: THREE.AdditiveBlending,
        depthTest: false,
        transparent: true,
        opacity: 0.9
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    /**
     * SHAPE GENERATORS
     */
    function getSpherePoint(r) {
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    const shapes = {
        sphere: () => {
            const radius = 12;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const p = getSpherePoint(radius);
                targetPositions[i*3] = p.x;
                targetPositions[i*3+1] = p.y;
                targetPositions[i*3+2] = p.z;
            }
        },
        heart: () => {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Heart Surface Equation
                let t = Math.random() * Math.PI * 2;
                // Distribute points to fill the volume
                const scale = 0.8;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                // Extrude Z for 3D
                const z = (Math.random() - 0.5) * 8; 
                
                // Add some random scatter
                targetPositions[i*3] = x * scale + (Math.random()-0.5);
                targetPositions[i*3+1] = y * scale + (Math.random()-0.5);
                targetPositions[i*3+2] = z;
            }
        },
        saturn: () => {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                if (i < PARTICLE_COUNT * 0.6) {
                    // Planet Body
                    const p = getSpherePoint(7);
                    targetPositions[i*3] = p.x;
                    targetPositions[i*3+1] = p.y;
                    targetPositions[i*3+2] = p.z;
                } else {
                    // Rings
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 10 + Math.random() * 8; // Ring width
                    
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    const y = (Math.random() - 0.5) * 0.5; // Thin ring

                    // Tilt
                    const tilt = 0.4;
                    targetPositions[i*3] = x;
                    targetPositions[i*3+1] = y * Math.cos(tilt) - z * Math.sin(tilt);
                    targetPositions[i*3+2] = y * Math.sin(tilt) + z * Math.cos(tilt);
                }
            }
        },
        flower: () => {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                // 5 petal modulation
                const r = 10 * (1 + 0.5 * Math.sin(5 * u) * Math.sin(v));
                
                targetPositions[i*3] = r * Math.sin(u) * Math.cos(v);
                targetPositions[i*3+1] = r * Math.cos(u) * Math.cos(v);
                targetPositions[i*3+2] = r * Math.sin(v);
            }
        },
        dna: () => {
             for (let i = 0; i < PARTICLE_COUNT; i++) {
                const h = (Math.random() - 0.5) * 30; // Height
                const angle = h * 0.5; // Twist factor
                const radius = 6;
                
                // Two strands
                const offset = Math.random() > 0.5 ? 0 : Math.PI;
                
                targetPositions[i*3] = Math.cos(angle + offset) * radius + (Math.random()-0.5);
                targetPositions[i*3+1] = h;
                targetPositions[i*3+2] = Math.sin(angle + offset) * radius + (Math.random()-0.5);
            }           
        },
        cube: () => {
            const size = 18;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                targetPositions[i*3] = (Math.random() - 0.5) * size;
                targetPositions[i*3+1] = (Math.random() - 0.5) * size;
                targetPositions[i*3+2] = (Math.random() - 0.5) * size;
            }
        }
    };

    /**
     * UI & INTERACTION LOGIC
     */
    window.setShape = (shapeName) => {
        if(shapes[shapeName]) shapes[shapeName]();
        
        // Update UI
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${shapeName}`).classList.add('active');
    };

    // Set Initial Shape
    setShape('sphere');

    // Tracking Variables
    let handPresent = false;
    let handX = 0.5; // Normalized 0-1
    let handY = 0.5; // Normalized 0-1
    let pinchDistance = 0.0; // 0 to 1 approx

    /**
     * ANIMATION LOOP
     */
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const delta = 0.08; // Morph speed

        const posAttr = geometry.attributes.position;
        const colAttr = geometry.attributes.color;
        
        // Dynamic color calculation
        const baseHue = handPresent ? handX : (time * 0.05) % 1;
        const colorObj = new THREE.Color();

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;
            
            // 1. Get Target Position (Base Shape)
            let tx = targetPositions[idx];
            let ty = targetPositions[idx+1];
            let tz = targetPositions[idx+2];

            // 2. Hand Interaction
            let scaleFactor = 1.0;
            
            if (handPresent) {
                // Map hand (0-1) to world coordinates approx (-20 to 20)
                const handWorldX = (1 - handX) * 40 - 20; // Flip X for mirror feel
                const handWorldY = (1 - handY) * 30 - 15;
                
                const px = posAttr.array[idx];
                const py = posAttr.array[idx+1];
                
                // Attraction force
                const dx = handWorldX - px;
                const dy = handWorldY - py;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < 10) {
                    // Pull particles towards hand gently
                    tx += dx * 0.3;
                    ty += dy * 0.3;
                }

                // Pinch Expansion/Compression
                // If pinch is small (fingers touching), compress. If wide, expand.
                // pinchDistance usually ~0.02 (closed) to 0.2 (open)
                
                // Normalized pinch factor: 1.0 is neutral
                // < 0.05 is pinch -> scale down
                // > 0.1 is open -> scale up
                
                let pinchEffect = (pinchDistance * 5); // 0.1 to 1.0 roughly
                if (pinchEffect < 0.2) pinchEffect = 0.2; // Min size
                if (pinchEffect > 1.5) pinchEffect = 1.5; // Max size
                
                scaleFactor = pinchEffect;
            } else {
                // Idle breathing
                scaleFactor = 1.0 + Math.sin(time * 2) * 0.05;
            }

            // Apply scaling from center
            tx *= scaleFactor;
            ty *= scaleFactor;
            tz *= scaleFactor;

            // 3. Move particles
            posAttr.array[idx] += (tx - posAttr.array[idx]) * delta;
            posAttr.array[idx+1] += (ty - posAttr.array[idx+1]) * delta;
            posAttr.array[idx+2] += (tz - posAttr.array[idx+2]) * delta;

            // 4. Color Update
            // Add some variation based on position
            const noise = (targetPositions[idx] * 0.02);
            colorObj.setHSL((baseHue + noise) % 1, 0.8, 0.6);
            
            colAttr.array[idx] = colorObj.r;
            colAttr.array[idx+1] = colorObj.g;
            colAttr.array[idx+2] = colorObj.b;
        }

        posAttr.needsUpdate = true;
        colAttr.needsUpdate = true;
        
        // Gentle global rotation
        scene.rotation.y = time * 0.1;
        scene.rotation.z = Math.sin(time * 0.2) * 0.05;

        renderer.render(scene, camera);
    }
    
    animate();

    /**
     * MEDIAPIPE HANDS SETUP
     */
    const videoElement = document.getElementById('input_video');
    const previewElement = document.getElementById('cam-preview');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            // Update Status
            if (!handPresent) {
                statusDot.classList.add('active');
                statusText.innerText = "Tracking Hand";
                statusText.style.color = "#00ff88";
            }
            handPresent = true;
            
            const landmarks = results.multiHandLandmarks[0];
            
            // 1. Calculate Hand Center (using Wrist [0] and Middle Finger MCP [9])
            const wrist = landmarks[0];
            const middleMcp = landmarks[9];
            
            handX = (wrist.x + middleMcp.x) / 2;
            handY = (wrist.y + middleMcp.y) / 2;

            // 2. Calculate Pinch Distance (Thumb Tip [4] vs Index Tip [8])
            const thumb = landmarks[4];
            const index = landmarks[8];
            
            // Euclidean distance in 2D plane is sufficient
            const d = Math.sqrt(Math.pow(thumb.x - index.x, 2) + Math.pow(thumb.y - index.y, 2));
            pinchDistance = d; 

        } else {
            if (handPresent) {
                statusDot.classList.remove('active');
                statusText.innerText = "No hand detected";
                statusText.style.color = "#ffffff";
            }
            handPresent = false;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // Initialize Camera
    // We use a separate stream for the preview to ensure the processing doesn't lag the UI
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });

    // Start Camera
    navigator.mediaDevices.getUserMedia({ video: true })
        .then((stream) => {
            videoElement.srcObject = stream;
            previewElement.srcObject = stream; // Show mirror
            cameraUtils.start();
        })
        .catch(err => {
            statusText.innerText = "Camera Access Denied";
            statusText.style.color = "red";
            console.error(err);
        });

    // Resize Handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>